## 基础类相关

### 面向对象的三大特性
- 封装，将事物的共同属性和方法抽象出来，封装到一个类中，使用时只需要关注类内方法的功能，不需要关注具体的底层实现方法
- 继承，一个类能够继承其它的类，进而使用父类的部分成员和方法，除此之外子类也有自己独有的方法和属性，子类也可以重写父类的方法
- 多态，实例所指向的具体类和引用的实例的方法在编程时并不确定，要到运行时才能确定
  
### switch支持哪些数据类型
char、 byte、int、short，后来又加了String 和 enum

### 访问修饰符号
- private：完全私有，只有类内成员能用
- default：类内和同包内可见
- protect：自己和子类能够使用
- public：任何人能够使用
private和protect不能修饰类

### final、finalize、finally的区别
- final修饰的变量不能更改，修饰的方法不能重写，修饰的类不能继承
- finalize：垃圾回收时调用的方法
- finally和try catch结构一起出现，finally块中的代码一定会执行，一般放一些关闭资源的逻辑

### this关键词
- 直接引用，相当于指向当前对象本身
- 形参与成员名字不同时进行区分
- 引用本类的构造函数
   
### static关键词
- 在没有创建实例的时候也能使用类内的属性和方法
- static的属性和方法不属于某个实例，而是属于类所有的实例所共有
- static修饰的部分，会在类第一次加载的时候进行加载
- static主要用于的场景：创建实例消耗资源较大，且只需要创建一次就能完成目标的任务

### 匿名内部类
- 必须实现一个接口或者继承一个类，而且不能是抽象的
- 内部不能定义静态成员和方法
- 所在方法的形参需要被匿名内部类使用时，需要定义为final，因为如果不定义为final，就会在方法结束时销毁，内部类对变量的应用依然存在，就会导致调用时出错

### ==和equals的区别
- 对于基础数据类型，==是比较变量的值，对于引用数据类型来说，==是比较内存地址
- equals未重写时比较内存地址，可以重写成比较实例的值是否相等。要注意的是String的equals方法被重写过
   
### hashCode和equals
重写equals必须重写hashCode
举例说明：hashSet放入数据的时候，会根据对象的hashcode值来计算放的位置，同时会与其它已经在集合中的对象的hashcode相比较，如果没有重复的，会直接插入，但是有重复的hashcode，就会再比较对象的内容是否相等，这样的话可以减少equals次数，大大提高执行速度

### BIO、NIO、AIO
- BIO: blocking IO，同步阻塞式IO，特点是使用简单，但是并发能力低，传输数据的时候会将通道阻塞
- NIO: non-blocking IO，同步非阻塞式IO，客户端和服务端使用channel进行连接，实现了多路复用
- AIO：asynchronous IO，异步非阻塞IO，异步操作基于事件和回调机制实现
  
### select、poll、epoll之间的区别
||select|poll|epoll|
|----|----|----|----|
|数据结构|bitmap|数组|红黑树|
|最大连接数|1024|无上限|无上限|
|fd拷贝|每次调用select拷贝|每次调用poll拷贝|fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝|
|工作效率|轮询 O(n)|轮询 O(n)|回调 O(1)|

### 反射
在运行状态中，对于任意一个类，我们能够知道其任意方法和属性。
优点：能够动态加载类，提高灵活度。缺点：反射相当于一系列解释操作，性能较差

### 获取反射的三种方法
- new 对象： Student stu = new Student(); Class s = stu.getClass();
- 路径，Class.forName: Class s = Class.forName("xxx.Student");
- 类名: Class s = Student.class;
   
### String的特点
- 不变性，immutable对象，被多个线程共享并频繁访问时，可以保证一致性
- 常量池优化，常量池位于方法区中
- 被final修饰，不能被继承，保证了安全性
### StringBuilder和StringBuffer
两个都继承自AbstractStringBuilder，StringBuffer加了同步锁，是线程安全的，但性能较差

## 集合 
