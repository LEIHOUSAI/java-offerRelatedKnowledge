### 3次握手
- 核心是让收发双方都知道自己和对方具有收发能力
- 客户端向服务端发请求，服务端收到后，服务端知道自己有接受能力，客户端有发送能力
- 服务端向客户端发请求，客户端收到后，客户端知道自己有收发能力，服务端有收发能力
- 这个时候服务端还不知道自己是否有发送能力、客户端是否有接收能力，所以需要第三次握手，客户端向服务端发请求，服务端知道自己有收发能力，客户端有收发能力
  
具体来讲就是：
1. client端建立连接，发送一个SYN同步包，发送之后状态变成SYN_SENT
2. server端收到SYN之后，同意建立连接，返回一个ACK响应，同时也会给client发送一个SYN包，发送完成之后状态变为SYN_RCVD
3. client端收到server的ACK之后，状态变为ESTABLISHED，返回ACK给server端。server收到之后状态也变为ESTABLISHED，连接建立完成。
   ![avatar](./image/network-1.png)

### 4次挥手
TCP协议是双向对等的传输协议，双方都可以向对方传输数据，接收对方的数据，所以要关闭连接的时候，A先给B指令（FIN），B接收到之后，回一个ACK，将一个方向上的连接关闭，但此时另一个方向的数据传输还在继续，等到传输完毕之后，B再给A发指令，A收到之后同样返回一个ack，将另一个方向上的连接关闭

具体来讲就是：
1. client端向server发送FIN包，进入FIN_WAIT_1状态，这代表client端已经没有数据要发送了
2. server端收到之后，返回一个ACK，进入CLOSE_WAIT等待关闭的状态，因为server端可能还有没有发送完成的数据
3. 等到server端数据都发送完毕之后，server端就向client发送FIN，进入LAST_ACK状态
4. client收到ACK之后，进入TIME_WAIT的状态，同时回复ACK，server收到之后直接进入CLOSED状态，连接关闭。但是client要等待2MSL(报文最大生存时间)的时间，才会进入CLOSED状态。
   ![avatar](./image/network-2.png)

### 为什么要等待2MSL的时间才关闭？
1. 为了保证连接的可靠关闭。如果server没有收到最后一个ACK，那么就会重发FIN。
2. 为了避免端口重用带来的数据混淆。如果client直接进入CLOSED状态，又用相同端口号向server建立一个连接，上一次连接的部分数据在网络中延迟到达server，数据就可能发生污染。

### TCP怎么保证传输过程的可靠性？
- 校验和：发送方在发送数据之前计算校验和，接收方收到数据后同样计算，如果不一致，那么传输有误。
- 确认应答，序列号：TCP进行传输时数据都进行了编号，每次接收方返回ACK都有确认序列号。
- 超时重传：如果发送方发送数据一段时间后没有收到ACK，那么就重发数据。
- 连接管理：三次握手和四次挥手的过程。
- 流量控制：TCP协议报头包含16位的窗口大小，接收方会在返回ACK时同时把自己的即时窗口填入，发送方就根据报文中窗口的大小控制发送速度。

### 浏览器请求一个网址的过程
1. 首先通过DNS服务器把域名解析成IP地址，通过IP和子网掩码判断是否属于同一个子网
2. 构造应用层请求http报文，传输层添加TCP/UDP头部，网络层添加IP头部，数据链路层添加以太网协议头部
3. 数据经过路由器、交换机转发，最终达到目标服务器，目标服务器同样解析数据，最终拿到http报文，按照对应的程序的逻辑响应回去。
   ![avatar](./image/network-3.png)

### HTTPS的工作原理
1. 用户通过浏览器请求https网站，服务器收到请求，选择浏览器支持的加密和hash算法，同时返回数字证书给浏览器，包含颁发机构、网址、公钥、证书有效期等信息。
2. 浏览器对证书的内容进行校验，如果有问题，则会有一个提示警告。否则，就生成一个随机数X，同时使用证书中的公钥进行加密，并且发送给服务器。
3. 服务器收到之后，使用私钥解密，得到随机数X，然后使用X对网页内容进行加密，返回给浏览器
4. 浏览器则使用X和之前约定的加密算法进行解密，得到最终的网页内容
   ![avatar](./image/network-4.png)

### BIO、NIO、AIO
- BIO: blocking IO，同步阻塞式IO，每一个客户端连接，服务端都会对应一个处理线程，对于没有分配到处理线程的连接就会被阻塞或者拒绝。相当于是一个连接一个线程。
  ![avatar](./image/network-5.png)
- NIO: non-blocking IO，同步非阻塞式IO，同步非阻塞IO，基于Reactor模型，客户端和channel进行通信，channel可以进行读写操作，通过多路复用器selector来轮询注册在其上的channel，而后再进行IO操作。这样的话，在进行IO操作的时候再用一个线程去处理就可以了，也就是一个请求一个线程。实现了多路复用
  ![avatar](./image/network-6.png)
- AIO：asynchronous IO，异步非阻塞IO，完全由操作系统来完成请求的处理，然后通知服务端开启线程去进行处理，因此是一个有效请求一个线程。异步操作基于事件和回调机制实现

### 那么你怎么理解同步和阻塞？
首先，可以认为一个IO操作包含两个部分：
1. 发起IO请求
2. 实际的IO读写操作
- 同步和异步在于第二个，实际的IO读写操作，如果操作系统帮你完成了再通知你，那就是异步，否则都叫做同步。
- 阻塞和非阻塞在于第一个，发起IO请求，对于NIO来说通过channel发起IO操作请求后，其实就返回了，所以是非阻塞。