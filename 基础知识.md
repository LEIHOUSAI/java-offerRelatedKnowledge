## 基础类相关

### 面向对象的三大特性
- 封装，将事物的共同属性和方法抽象出来，封装到一个类中，使用时只需要关注类内方法的功能，不需要关注具体的底层实现方法
- 继承，一个类能够继承其它的类，进而使用父类的部分成员和方法，除此之外子类也有自己独有的方法和属性，子类也可以重写父类的方法
- 多态，实例所指向的具体类和引用的实例的方法在编程时并不确定，要到运行时才能确定
  
### switch支持哪些数据类型
char、 byte、int、short，后来又加了String 和 enum

### 访问修饰符号
- private：完全私有，只有类内成员能用
- default：类内和同包内可见
- protect：自己和子类能够使用
- public：任何人能够使用
private和protect不能修饰类

### final、finalize、finally的区别
- final修饰的变量不能更改，修饰的方法不能重写，修饰的类不能继承
- finalize：垃圾回收时调用的方法
- finally和try catch结构一起出现，finally块中的代码一定会执行，一般放一些关闭资源的逻辑

### this关键词
- 直接引用，相当于指向当前对象本身
- 形参与成员名字不同时进行区分
- 引用本类的构造函数
   
### static关键词
- 在没有创建实例的时候也能使用类内的属性和方法
- static的属性和方法不属于某个实例，而是属于类所有的实例所共有
- static修饰的部分，会在类第一次加载的时候进行加载
- static主要用于的场景：创建实例消耗资源较大，且只需要创建一次就能完成目标的任务

### 匿名内部类
- 必须实现一个接口或者继承一个类，而且不能是抽象的
- 内部不能定义静态成员和方法
- 所在方法的形参需要被匿名内部类使用时，需要定义为final，因为如果不定义为final，就会在方法结束时销毁，内部类对变量的应用依然存在，就会导致调用时出错

### ==和equals的区别
- 对于基础数据类型，==是比较变量的值，对于引用数据类型来说，==是比较内存地址
- equals未重写时比较内存地址，可以重写成比较实例的值是否相等。要注意的是String的equals方法被重写过
   
### hashCode和equals
重写equals必须重写hashCode
举例说明：hashSet放入数据的时候，会根据对象的hashcode值来计算放的位置，同时会与其它已经在集合中的对象的hashcode相比较，如果没有重复的，会直接插入，但是有重复的hashcode，就会再比较对象的内容是否相等，这样的话可以减少equals次数，大大提高执行速度

### BIO、NIO、AIO
- BIO: blocking IO，同步阻塞式IO，特点是使用简单，但是并发能力低，传输数据的时候会将通道阻塞
- NIO: non-blocking IO，同步非阻塞式IO，客户端和服务端使用channel进行连接，实现了多路复用
- AIO：asynchronous IO，异步非阻塞IO，异步操作基于事件和回调机制实现
  
### select、poll、epoll之间的区别
|            | select             | poll             | epoll                                             |
| ---------- | ------------------ | ---------------- | ------------------------------------------------- |
| 数据结构   | bitmap             | 数组             | 红黑树                                            |
| 最大连接数 | 1024               | 无上限           | 无上限                                            |
| fd拷贝     | 每次调用select拷贝 | 每次调用poll拷贝 | fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝 |
| 工作效率   | 轮询 O(n)          | 轮询 O(n)        | 回调 O(1)                                         |

### 反射
在运行状态中，对于任意一个类，我们能够知道其任意方法和属性。
优点：能够动态加载类，提高灵活度。缺点：反射相当于一系列解释操作，性能较差

### 获取反射的三种方法
- new 对象： Student stu = new Student(); Class s = stu.getClass();
- 路径，Class.forName: Class s = Class.forName("xxx.Student");
- 类名: Class s = Student.class;
   
### String的特点
- 不变性，immutable对象，被多个线程共享并频繁访问时，可以保证一致性
- 常量池优化，常量池位于方法区中
- 被final修饰，不能被继承，保证了安全性
### StringBuilder和StringBuffer
两个都继承自AbstractStringBuilder，StringBuffer加了同步锁，是线程安全的，但性能较差

## 集合 

### 集合和数组的区别
- 集合是可变长度的，数组是定长的
- 数组能够存基本和引用数据类型，集合只能存引用数据类型
- 数组存储的元素必须是同一数据类型，集合存储的可以是不同数据类型

### 数组和list的互转
- 数组转list：Arrays.toList(arrays)
- list转数组：list.toArray()

### ArrayList和LinkedList的区别
- ArrayList底层是数组实现的，LinkedList是双向链表实现的
- ArrayList实现了RandomAccess接口，查找元素较快，LinkedList因为是线性数据存储方式，所以随机查找元素较慢
- ArrayList插入和删除元素因为有复制的动作，所以比LinkedList慢
- LinkedList比ArrayList更占内存，因为需要存储两个引用，一个指向前一个元素，一个指向后一个
- 两个都不是线程安全的

### ArrayList如何保证多线程下的线程安全
可以使用synchronizedList方法，转换成线程安全容器后再使用

### Queue中的poll()和remove()方法
它们都是返回第一个元素，并删除，但是用poll()，队列为空时会返回null，而remove()会直接报错

### HashMap的运行原理
- put数据时，首先根据key的hashcode计算出在数组中的下标，如果出现了相同hashcode的key，就会再次判断key值是否相等
- key值相等，则覆盖原始值，如果key不同，则将key-value放入链表中
- 获取数据时，首先根据hashcode找到在数组中的下标，再比较key，找到对应值
- jdk1.8之后，链表超过8个元素，且数组长度大于64的情况下，链表会转化为红黑树，查询效率由O(n) -> O(logn)，数组长度小于64会优先进行扩容

### HashMap源码

### ParallelStream

## 异常

### 受检异常和非受检异常
- 受检异常为除RuntimeException之外的其它Exception
- 非受检异常为Error和RuntimeException及其子类

### catch中有return，finally还会执行吗
会在return前执行，而且如果finally中也有return，会覆盖catch中的return

## jvm相关

### 内存区包括哪几部分
- 方法区，用于存储类结构信息的地方，包括常量池、静态变量、构造函数等
- java堆，用来存储实例，是GC的主要区域
- java栈，每个线程对应一个栈，每运行一个方法就创建一个栈帧。每一个方法从调用直至返回，就对应的是栈帧在java栈中入栈到出栈的过程。jva栈是线程私有的
- 程序计数器，也是线程私有的
- 本地方法栈

### 垃圾回收算法
- 标记 - 清除，缺点是会产生大量碎片
- 复制，缺点是需要2倍空间
- 标记 - 整理
- 分代收集，将对象按照生命周期的不同划分成：年轻代、年老代、持久代。其中持久代主要放类信息，和GC的关系不大
  
### 满足垃圾回收的两个条件

### 能做root的都有什么

### 简单描述垃圾收集过程
当对象创建的时候，垃圾回收器就会监控对象的地址、大小和使用情况，当满足2个条件（引用计数器归零，不可达）之一，就会触发垃圾回收，此时对象属于属于年轻代，eden区，eden区满了之后就会执行一次minor GC，存活下来的进入Survivor中的From，From中也会进行minor GC，存活下来的会进入To，From到To穿梭一次，年龄会+1，当年龄到15之后会进入年老代，年老代每隔一段时间会执行一次full GC/major GC

### 常用垃圾回收器
#### Serial收集器
Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了，通过名称就可以看出该垃圾收集器是一个单线程收集器。它的单线程的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作时候必须暂停其它所有的线程（Stop the world）， 直到它收集结束。
- 新生代采用复制算法，老年代采用标记-整理算法
#### ParNew收集器
ParNew收集器其实就是Serial的多线程版本，除了使用多线程进行垃圾收集之外，其余行为（控制参数、收集算法、回收策略等）和Serial收集器完全一样。
#### Parallel Scavenge收集器
Parallel Scavenge收集器关注是吞吐量（高效的复用cpu）， CMS关注的点更多的是用户线程的停顿时间（提高用户体验）
#### CMS收集器
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是Hotspot虚拟机第一款真正意义上的并发收集器，第一次实现了：一定程度上让垃圾收集线程与用户线程同时工作
CMS收集器是一种标记-清除算法实现的，它的运行过程相比于前面几种垃圾收集器更复杂一些.整个过程分为如下几个步骤：
- 初始标记：暂停所有的其它线程，并记录下直接与root相连的对象，速度很快。
- 并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- 重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。
- 并发清除：开启用户线程，同时GC线程开始对为标记的区域做清扫。
#### G1收集器

### 比较CMS和G1垃圾回收器区别
- 作用区域:CMS是老年代回收器，G1是年轻代和老年代 
- 回收算法:CMS是标记清除，G1是标记整理 
- G1对内存空间划分为Region, CMS为新生代、老年代
- G1可预测停顿时间，两者都是并行回收

### 有没有过垃圾回收参数调优经验
自己用过parallel scavenge收集器，测试的时候发现前端无法响应，young gc比较频繁
解决：ParallelGCThreads，如果你没有设置该参数，该参数jvm会默认设置成online的cpu的核数，但并不包括被shutdown的cpu的核数。gc线程数默认设置的是物理机的核心线程数，改为容器的核心线程数后，得到恢复
更多调优参考：https://juejin.cn/post/6844903991713742855

## 其它

### 3次握手
- 核心是让收发双方都知道自己和对方具有收发能力
- 客户端向服务端发请求，服务端收到后，服务端知道自己有接受能力，客户端有发送能力
- 服务端向客户端发请求，客户端收到后，客户端知道自己有收发能力，服务端有收发能力
- 这个时候服务端还不知道自己是否有发送能力、客户端是否有接收能力，所以需要第三次握手，客户端向服务端发请求，服务端知道自己有收发能力，客户端有收发能力

### 4次挥手
TCP协议是双向对等的传输协议，双方都可以向对方传输数据，接收对方的数据，所以要关闭连接的时候，A先给B指令，B接收到之后，回一个ACK，将一个方向上的连接关闭，但此时另一个方向的数据传输还在继续，等到传输完毕之后，B再给A发指令，A收到之后同样返回一个ack，将另一个方向上的连接关闭

### 订单号生成
- 第一部分是业务/供应商名字缩写
- 第二部分是和时间相关，精确到毫秒
- 第三部分：定一个原子类和timestamp，每次生成订单号时比较当前时间和timestamp，如果不相等则直接取原子类初始值，如果相等则原子类+1，然后限定一个范围即可，我们的业务不会出现每毫秒订单号超过100的情况，所以原子类上限到99即可，如果有超过99的极端情况出现，则维护一个while循环，重新取当前时间和timestamp进行比较

### 雪花算法